const DitherLib = (() => {
  "use strict";

  const D = {
    algorithm: "floyd-steinberg",
    isColor: false,
    levels: 8,
    contrast: 1,
    brightness: 0,
    diffusion: 1,
    palette: null,
    serpentine: false,
    fps: 30,
    linearize: false,
    errorMultiplier: 1.0,
  };

  const P = {
    gameboy: [
      { r: 15, g: 56, b: 15 },
      { r: 48, g: 98, b: 48 },
      { r: 139, g: 172, b: 15 },
      { r: 155, g: 188, b: 15 },
    ],
    gameboyPocket: [
      { r: 0, g: 0, b: 0 },
      { r: 85, g: 85, b: 85 },
      { r: 170, g: 170, b: 170 },
      { r: 255, g: 255, b: 255 },
    ],
    cga: [
      { r: 0, g: 0, b: 0 },
      { r: 85, g: 255, b: 255 },
      { r: 255, g: 85, b: 255 },
      { r: 255, g: 255, b: 255 },
    ],
    cgaPalette1: [
      { r: 0, g: 0, b: 0 },
      { r: 0, g: 170, b: 170 },
      { r: 170, g: 0, b: 170 },
      { r: 170, g: 170, b: 170 },
    ],
    ega: [
      { r: 0, g: 0, b: 0 },
      { r: 0, g: 0, b: 170 },
      { r: 0, g: 170, b: 0 },
      { r: 0, g: 170, b: 170 },
      { r: 170, g: 0, b: 0 },
      { r: 170, g: 0, b: 170 },
      { r: 170, g: 85, b: 0 },
      { r: 170, g: 170, b: 170 },
      { r: 85, g: 85, b: 85 },
      { r: 85, g: 85, b: 255 },
      { r: 85, g: 255, b: 85 },
      { r: 85, g: 255, b: 255 },
      { r: 255, g: 85, b: 85 },
      { r: 255, g: 85, b: 255 },
      { r: 255, g: 255, b: 85 },
      { r: 255, g: 255, b: 255 },
    ],
    bw: [
      { r: 0, g: 0, b: 0 },
      { r: 255, g: 255, b: 255 },
    ],
    c64: [
      { r: 0, g: 0, b: 0 },
      { r: 255, g: 255, b: 255 },
      { r: 136, g: 0, b: 0 },
      { r: 170, g: 255, b: 238 },
      { r: 204, g: 68, b: 204 },
      { r: 0, g: 204, b: 85 },
      { r: 0, g: 0, b: 170 },
      { r: 238, g: 238, b: 119 },
      { r: 221, g: 136, b: 85 },
      { r: 102, g: 68, b: 0 },
      { r: 255, g: 119, b: 119 },
      { r: 51, g: 51, b: 51 },
      { r: 119, g: 119, b: 119 },
      { r: 170, g: 255, b: 102 },
      { r: 0, g: 136, b: 255 },
      { r: 187, g: 187, b: 187 },
    ],
    apple2: [
      { r: 0, g: 0, b: 0 },
      { r: 114, g: 38, b: 64 },
      { r: 64, g: 51, b: 127 },
      { r: 228, g: 52, b: 254 },
      { r: 14, g: 89, b: 64 },
      { r: 128, g: 128, b: 128 },
      { r: 27, g: 154, b: 254 },
      { r: 191, g: 179, b: 255 },
      { r: 64, g: 76, b: 0 },
      { r: 228, g: 101, b: 1 },
      { r: 128, g: 128, b: 128 },
      { r: 241, g: 166, b: 191 },
      { r: 27, g: 203, b: 1 },
      { r: 191, g: 204, b: 128 },
      { r: 141, g: 217, b: 191 },
      { r: 255, g: 255, b: 255 },
    ],
    sepia: [
      { r: 0, g: 0, b: 0 },
      { r: 112, g: 66, b: 20 },
      { r: 192, g: 156, b: 92 },
      { r: 255, g: 240, b: 206 },
    ],
  };

  const M = {
    "floyd-steinberg": [
      [1, 0, 7 / 16],
      [-1, 1, 3 / 16],
      [0, 1, 5 / 16],
      [1, 1, 1 / 16],
    ],
    atkinson: [
      [1, 0, 1 / 8],
      [2, 0, 1 / 8],
      [-1, 1, 1 / 8],
      [0, 1, 1 / 8],
      [1, 1, 1 / 8],
      [0, 2, 1 / 8],
    ],
    "jarvis-judice-ninke": [
      [1, 0, 7 / 48],
      [2, 0, 5 / 48],
      [-2, 1, 3 / 48],
      [-1, 1, 5 / 48],
      [0, 1, 7 / 48],
      [1, 1, 5 / 48],
      [2, 1, 3 / 48],
      [-2, 2, 1 / 48],
      [-1, 2, 3 / 48],
      [0, 2, 5 / 48],
      [1, 2, 3 / 48],
      [2, 2, 1 / 48],
    ],
    stucki: [
      [1, 0, 8 / 42],
      [2, 0, 4 / 42],
      [-2, 1, 2 / 42],
      [-1, 1, 4 / 42],
      [0, 1, 8 / 42],
      [1, 1, 4 / 42],
      [2, 1, 2 / 42],
      [-2, 2, 1 / 42],
      [-1, 2, 2 / 42],
      [0, 2, 4 / 42],
      [1, 2, 2 / 42],
      [2, 2, 1 / 42],
    ],
    burkes: [
      [1, 0, 8 / 32],
      [2, 0, 4 / 32],
      [-2, 1, 2 / 32],
      [-1, 1, 4 / 32],
      [0, 1, 8 / 32],
      [1, 1, 4 / 32],
      [2, 1, 2 / 32],
    ],
    sierra: [
      [1, 0, 5 / 32],
      [2, 0, 3 / 32],
      [-2, 1, 2 / 32],
      [-1, 1, 4 / 32],
      [0, 1, 5 / 32],
      [1, 1, 4 / 32],
      [2, 1, 2 / 32],
      [-1, 2, 2 / 32],
      [0, 2, 3 / 32],
      [1, 2, 2 / 32],
    ],
    "sierra-2": [
      [1, 0, 4 / 16],
      [2, 0, 3 / 16],
      [-2, 1, 1 / 16],
      [-1, 1, 2 / 16],
      [0, 1, 3 / 16],
      [1, 1, 2 / 16],
      [2, 1, 1 / 16],
    ],
    "sierra-lite": [
      [1, 0, 2 / 4],
      [-1, 1, 1 / 4],
      [0, 1, 1 / 4],
    ],
    fan: [
      [1, 0, 7 / 16],
      [-1, 1, 1 / 16],
      [0, 1, 5 / 16],
      [1, 1, 3 / 16],
    ],
  };

  const B = {
    2: [
      [0, 2],
      [3, 1],
    ],
    4: [
      [0, 8, 2, 10],
      [12, 4, 14, 6],
      [3, 11, 1, 9],
      [15, 7, 13, 5],
    ],
    8: [
      [0, 32, 8, 40, 2, 34, 10, 42],
      [48, 16, 56, 24, 50, 18, 58, 26],
      [12, 44, 4, 36, 14, 46, 6, 38],
      [60, 28, 52, 20, 62, 30, 54, 22],
      [3, 35, 11, 43, 1, 33, 9, 41],
      [51, 19, 59, 27, 49, 17, 57, 25],
      [15, 47, 7, 39, 13, 45, 5, 37],
      [63, 31, 55, 23, 61, 29, 53, 21],
    ],
  };

  const clamp = (v, min = 0, max = 255) => Math.max(min, Math.min(max, v));

  const dist = (r1, g1, b1, r2, g2, b2) =>
    Math.sqrt((r1 - r2) ** 2 + (g1 - g2) ** 2 + (b1 - b2) ** 2);

  const gray = (r, g, b) => 0.299 * r + 0.587 * g + 0.114 * b;

  const parse = (e) => {
    const c = { ...D };
    if (e.hasAttribute("dither"))
      c.algorithm = e.getAttribute("dither") || c.algorithm;
    if (e.hasAttribute("dither-color"))
      c.isColor = e.getAttribute("dither-color") === "true";
    if (e.hasAttribute("dither-levels"))
      c.levels = parseInt(e.getAttribute("dither-levels")) || c.levels;
    if (e.hasAttribute("dither-contrast"))
      c.contrast = parseFloat(e.getAttribute("dither-contrast")) || c.contrast;
    if (e.hasAttribute("dither-brightness"))
      c.brightness =
        parseFloat(e.getAttribute("dither-brightness")) || c.brightness;
    if (e.hasAttribute("dither-palette"))
      c.palette = e.getAttribute("dither-palette");
    if (e.hasAttribute("dither-diffusion"))
      c.diffusion =
        parseFloat(e.getAttribute("dither-diffusion")) || c.diffusion;
    if (e.hasAttribute("dither-serpentine"))
      c.serpentine = e.getAttribute("dither-serpentine") === "true";
    if (e.hasAttribute("dither-fps"))
      c.fps = parseInt(e.getAttribute("dither-fps")) || c.fps;
    if (e.hasAttribute("dither-linearize"))
      c.linearize = e.getAttribute("dither-linearize") === "true";
    if (e.hasAttribute("dither-error-multiplier"))
      c.errorMultiplier =
        parseFloat(e.getAttribute("dither-error-multiplier")) ||
        c.errorMultiplier;
    return c;
  };

  const valid = (c) => {
    const v = { ...D, ...c };
    v.levels = Math.max(2, Math.min(256, v.levels));
    v.contrast = Math.max(0.1, Math.min(3, v.contrast));
    v.brightness = Math.max(-1, Math.min(1, v.brightness));
    v.diffusion = Math.max(0, Math.min(1, v.diffusion));
    v.fps = Math.max(1, Math.min(60, v.fps));
    v.errorMultiplier = Math.max(0, Math.min(2, v.errorMultiplier));
    return v;
  };

  const genPal = (l, c) => {
    const p = [];
    const s = 255 / (l - 1);
    if (c) {
      for (let r = 0; r < l; r++)
        for (let g = 0; g < l; g++)
          for (let b = 0; b < l; b++) {
            p.push({
              r: Math.round(r * s),
              g: Math.round(g * s),
              b: Math.round(b * s),
            });
          }
    } else {
      for (let i = 0; i < l; i++) {
        const v = Math.round(i * s);
        p.push({ r: v, g: v, b: v });
      }
    }
    return p;
  };

  const closest = (r, g, b, p) => {
    let m = Infinity,
      c = p[0];
    for (let i = 0; i < p.length; i++) {
      const d = dist(r, g, b, p[i].r, p[i].g, p[i].b);
      if (d < m) {
        m = d;
        c = p[i];
      }
    }
    return c;
  };

  const errDiff = (d, c, p) => {
    const { data, width: w, height: h } = d;
    const m = M[c.algorithm];
    if (!m) return errDiff(d, { ...c, algorithm: "floyd-steinberg" }, p);

    const errorR = new Float32Array(w * h);
    const errorG = new Float32Array(w * h);
    const errorB = new Float32Array(w * h);

    for (let y = 0; y < h; y++) {
      const dir = c.serpentine && y % 2 === 1 ? -1 : 1;
      const xs = dir === 1 ? 0 : w - 1;
      const xe = dir === 1 ? w : -1;

      for (let x = xs; x !== xe; x += dir) {
        const i = (y * w + x) * 4;
        const ei = y * w + x;

        let r = data[i] + errorR[ei];
        let g = data[i + 1] + errorG[ei];
        let b = data[i + 2] + errorB[ei];

        if (!c.isColor && !c.palette) {
          const gr = gray(r, g, b);
          r = g = b = gr;
        }

        r = clamp(r);
        g = clamp(g);
        b = clamp(b);

        const cl = closest(r, g, b, p);

        const er = (r - cl.r) * c.diffusion * c.errorMultiplier;
        const eg = (g - cl.g) * c.diffusion * c.errorMultiplier;
        const eb = (b - cl.b) * c.diffusion * c.errorMultiplier;

        data[i] = cl.r;
        data[i + 1] = cl.g;
        data[i + 2] = cl.b;

        for (let j = 0; j < m.length; j++) {
          let [dx, dy, weight] = m[j];
          if (dir === -1) dx = -dx;
          const nx = x + dx,
            ny = y + dy;
          if (nx >= 0 && nx < w && ny < h) {
            const ni = ny * w + nx;
            errorR[ni] += er * weight;
            errorG[ni] += eg * weight;
            errorB[ni] += eb * weight;
          }
        }
      }
    }
  };

  const ordered = (d, c, p) => {
    const { data, width: w, height: h } = d;
    const bs = c.bayerSize || 4;
    const b = B[bs] || B[4];
    const bn = b.length;
    const bm = bn * bn;

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const i = (y * w + x) * 4;
        let r = data[i],
          g = data[i + 1],
          bl = data[i + 2];

        if (!c.isColor && !c.palette) {
          const gr = gray(r, g, bl);
          r = g = bl = gr;
        }

        const t = (b[y % bn][x % bn] / bm - 0.5) * 255;
        r = r + t;
        g = g + t;
        bl = bl + t;

        const cl = closest(clamp(r), clamp(g), clamp(bl), p);
        data[i] = cl.r;
        data[i + 1] = cl.g;
        data[i + 2] = cl.b;
      }
    }
  };

  const threshold = (d, c, p) => {
    const { data, width: w, height: h } = d;
    const t = c.threshold || 128;

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const i = (y * w + x) * 4;
        let r = data[i],
          g = data[i + 1],
          b = data[i + 2];

        if (!c.isColor && !c.palette) {
          const gr = gray(r, g, b);
          r = g = b = gr;
        }

        const cl = r > t && g > t && b > t ? p[p.length - 1] : p[0];
        data[i] = cl.r;
        data[i + 1] = cl.g;
        data[i + 2] = cl.b;
      }
    }
  };

  const random = (d, c, p) => {
    const { data, width: w, height: h } = d;
    const rs = c.randomStrength || 64;

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const i = (y * w + x) * 4;
        let r = data[i],
          g = data[i + 1],
          b = data[i + 2];

        if (!c.isColor && !c.palette) {
          const gr = gray(r, g, b);
          r = g = b = gr;
        }

        const n = (Math.random() - 0.5) * rs;
        r = clamp(r + n);
        g = clamp(g + n);
        b = clamp(b + n);

        const cl = closest(r, g, b, p);
        data[i] = cl.r;
        data[i + 1] = cl.g;
        data[i + 2] = cl.b;
      }
    }
  };

  const engine = (d, c, p) => {
    const a = c.algorithm.toLowerCase();
    if (a === "ordered" || a === "bayer") ordered(d, c, p);
    else if (a === "random" || a === "noise") random(d, c, p);
    else if (a === "threshold" || a === "bitmap") threshold(d, c, p);
    else if (M[a]) errDiff(d, c, p);
    else errDiff(d, { ...c, algorithm: "floyd-steinberg" }, p);
  };

  const img = (im, uc = {}) => {
    try {
      const cv = document.createElement("canvas");
      const cx = cv.getContext("2d");
      if (!cx) return false;

      const c = valid(
        typeof uc === "object" && !im.hasAttribute("dither") ? uc : parse(im)
      );

      cv.width = im.naturalWidth || im.width;
      cv.height = im.naturalHeight || im.height;

      if (cv.width === 0 || cv.height === 0) return false;

      cx.filter = `contrast(${c.contrast}) brightness(${1 + c.brightness})`;
      cx.drawImage(im, 0, 0);
      cx.filter = "none";

      const id = cx.getImageData(0, 0, cv.width, cv.height);
      const p =
        c.palette && P[c.palette]
          ? P[c.palette]
          : genPal(c.levels, c.isColor);

      engine(id, c, p);

      cx.putImageData(id, 0, 0);
      im.src = cv.toDataURL();
      im.style.imageRendering = "pixelated";

      return true;
    } catch (e) {
      console.error("DitherLib error:", e);
      return false;
    }
  };

  const canvas = (cv, uc = {}) => {
    try {
      const cx = cv.getContext("2d");
      if (!cx) return false;

      const c = valid(uc);
      const id = cx.getImageData(0, 0, cv.width, cv.height);
      const p =
        c.palette && P[c.palette]
          ? P[c.palette]
          : genPal(c.levels, c.isColor);

      engine(id, c, p);

      cx.putImageData(id, 0, 0);
      return true;
    } catch (e) {
      console.error("DitherLib error:", e);
      return false;
    }
  };

  const video = (v, oc, uc = {}) => {
    try {
      const c = valid(uc);
      const cx = oc.getContext("2d");
      if (!cx) return null;

      oc.width = v.videoWidth || v.width;
      oc.height = v.videoHeight || v.height;

      const p =
        c.palette && P[c.palette]
          ? P[c.palette]
          : genPal(c.levels, c.isColor);

      let run = true;
      let last = 0;
      const fi = 1000 / c.fps;

      const proc = (t) => {
        if (!run) return;
        if (t - last >= fi) {
          cx.filter = `contrast(${c.contrast}) brightness(${1 + c.brightness})`;
          cx.drawImage(v, 0, 0, oc.width, oc.height);
          cx.filter = "none";

          const id = cx.getImageData(0, 0, oc.width, oc.height);
          engine(id, c, p);
          cx.putImageData(id, 0, 0);

          last = t;
        }
        requestAnimationFrame(proc);
      };

      requestAnimationFrame(proc);

      return {
        stop: () => {
          run = false;
        },
        start: () => {
          run = true;
          requestAnimationFrame(proc);
        },
      };
    } catch (e) {
      console.error("DitherLib error:", e);
      return null;
    }
  };

  const init = async (s = "img[dither], video[dither]") => {
    const els = document.querySelectorAll(s);
    const proms = [];

    for (let e of els) {
      if (e.tagName === "VIDEO") {
        const cv = document.createElement("canvas");
        cv.className = e.className;
        cv.style.cssText = e.style.cssText;
        e.parentNode.insertBefore(cv, e);
        e.style.display = "none";

        const pv = () => {
          if (e.readyState >= 2) {
            video(e, cv, parse(e));
          } else {
            e.addEventListener("loadeddata", () => {
              video(e, cv, parse(e));
            });
          }
        };

        if (e.paused) {
          e.play().then(pv).catch(pv);
        } else {
          pv();
        }
        proms.push(Promise.resolve(true));
      } else {
        if (e.complete) {
          proms.push(Promise.resolve(img(e)));
        } else {
          proms.push(
            new Promise((r) => {
              e.onload = () => r(img(e));
              e.onerror = () => r(false);
            })
          );
        }
      }
    }

    const res = await Promise.all(proms);
    return res.filter((r) => r).length;
  };

  return {
    init,
    apply: img,
    applyToImage: img,
    applyToCanvas: canvas,
    applyToVideo: video,
    palettes: P,
    algorithms: Object.keys(M).concat([
      "ordered",
      "bayer",
      "random",
      "noise",
      "threshold",
      "bitmap",
    ]),
    version: "2.1.0",
  };
})();

if (typeof window !== "undefined") {
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => DitherLib.init());
  } else {
    DitherLib.init();
  }
}

if (typeof module !== "undefined" && module.exports) {
  module.exports = DitherLib;
}
